Index: Example.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\"\"\"\r\n\r\nThis code finds the shortest path between two points in a maze\r\nusing the A* search algorithm.\r\nThe maze is provided as a 2D array in the \"Utilities.py\" class.\r\n\r\nThe maze contains numbers that indicate the cost of traveling into\r\na particular space.\r\nA number 0 indicates that it is not possible to enter that space.\r\n\r\nUser can choose between 4 distinct heuristic functions. User can also choose\r\nbetween allowing diagonal movement or not. For this assignment, it will not\r\nchoose diagonal as default.\r\n\r\nAssumptions:\r\n    The code will not loop to chose other maps.\r\n\r\n\"\"\"\r\n\r\nimport random\r\nimport heapq\r\nimport numpy as np\r\nimport timeit\r\nimport matplotlib.pyplot as plt\r\n\r\nclass Node:\r\n    \"\"\"\r\n    A node class for A* Pathfinding\r\n    \"\"\"\r\n\r\n    def __init__(self, parent=None, position=None):\r\n        self.parent = parent\r\n        self.position = position\r\n\r\n        self.g = 0\r\n        self.h = 0\r\n        self.f = 0\r\n\r\n    def __eq__(self, other):\r\n        return self.position == other.position\r\n\r\n    def __repr__(self):\r\n        return f\"{self.position} - g: {self.g} h: {self.h} f: {self.f}\"\r\n\r\n    # defining less than for purposes of heap queue\r\n    def __lt__(self, other):\r\n        return self.f < other.f\r\n\r\n    # defining greater than for purposes of heap queue\r\n    def __gt__(self, other):\r\n        return self.f > other.f\r\n\r\n\r\ndef return_path(current_node):\r\n    path = []\r\n    current = current_node\r\n    while current is not None:\r\n        path.append(current.position)\r\n        current = current.parent\r\n    return path[::-1]  # Return reversed path\r\n\r\ndef heuristic_function(i, new_node, end_node):\r\n    if i == 0: return 0;\r\n    #Manhattan Distance\r\n    if i == 1: return abs(new_node.position[0] - end_node.position[0]) + abs(new_node.position[1] - end_node.position[1])  # Manhattan distance.\r\n    #Euclidean Distance\r\n    if i == 2: return np.sqrt((new_node.position[0] - end_node.position[0]) ** 2 + (new_node.position[1] - end_node.position[1]) ** 2) # Euclidean distance.\r\n    #Manhattan Distance with added errors.\r\n    if i == 3: return abs(new_node.position[0] - end_node.position[0]) + abs(new_node.position[1] - end_node.position[1]) + random.randint(-3, 3)  # Manhattan distance + Random number.\r\n\r\n\"\"\"\r\n    Returns a list of tuples as a path from the given start to the given end in the given maze\r\n    :param maze:\r\n    :param start:\r\n    :param end:\r\n    :return path: \r\n    \"\"\"\r\n\r\ndef astar(maze, start, end, heuristic, allow_diagonal_movement = False):\r\n    start_node = Node(None, start)\r\n    end_node = Node(None, end)\r\n\r\n    open_list = []\r\n    closed_list = []\r\n    heapq.heapify(open_list)\r\n    heapq.heappush(open_list, start_node)\r\n\r\n    movement_directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]  # Up, Down, Left, Right\r\n    if allow_diagonal_movement:\r\n        movement_directions += [(-1, -1), (-1, 1), (1, -1), (1, 1)]\r\n\r\n    while len(open_list) > 0:\r\n        current_node = heapq.heappop(open_list)\r\n        closed_list.append(current_node)\r\n\r\n        if current_node == end_node:\r\n            return return_path(current_node)\r\n\r\n        children = []\r\n\r\n        for move in movement_directions:\r\n            node_position = (current_node.position[0] + move[0], current_node.position[1] + move[1])\r\n\r\n            if node_position[0] > (len(maze) - 1) or node_position[0] < 0 or node_position[1] > (len(maze[0]) - 1) or \\\r\n                    node_position[1] < 0:\r\n                continue\r\n\r\n            terrain_cost = maze[node_position[0]][node_position[1]]\r\n\r\n            if terrain_cost == 0:\r\n                continue\r\n\r\n            new_node = Node(current_node, node_position)\r\n            new_node.g = current_node.g + terrain_cost\r\n            new_node.h = heuristic_function(heuristic, new_node, end_node)\r\n            new_node.f = new_node.g + new_node.h\r\n\r\n            if len([closed_child for closed_child in closed_list if closed_child == new_node]) > 0:\r\n                continue\r\n\r\n            if len([open_node for open_node in open_list if\r\n                    new_node.position == open_node.position and new_node.g > open_node.g]) > 0:\r\n                continue\r\n\r\n            heapq.heappush(open_list, new_node)\r\n\r\n    #warn(\"Couldn't find a path to the destination\")\r\n    return None\r\n\r\n\r\ndef print_info(start, end, maze, path, print_extra = False):\r\n\r\n    print(\"Path cost: \", calculate_path_cost(maze, path))\r\n    print(\"Manhattan distance: \", calculate_manhattan_distance(start, end))\r\n    print(path)\r\n    if print_extra:\r\n        print(np.matrix(maze))\r\n        path_printer(maze, path, start, end)\r\n\r\ndef path_printer(maze, path, start, end):\r\n    if path is None: return \"No Solution\"\r\n    print(\" \", end=\" \")\r\n    for row in range(len(maze[0])): print(row, end = \" \")\r\n    print(\"\")\r\n    for i in range(len(maze)):\r\n        print(i, end = \" \")\r\n        for j in range(len(maze[i])):\r\n            if (i, j) == start:\r\n                print(\"@\", end = \" \")\r\n                continue\r\n            if (i, j) == end:\r\n                print(\"%\", end = \" \")\r\n                continue\r\n            elif (i, j) in path:\r\n                print(\"X\", end=\" \")\r\n            else:\r\n                print(\"O\", end=\" \")\r\n        print()  # Print a newline after each row\r\n\r\ndef start_aligner (i):\r\n    if i == 1:\r\n        return 1,2\r\n    elif i == 2:\r\n        return 3,6\r\n    elif i == 3:\r\n        return 1,2\r\n    elif i == 4:\r\n        return 1,1\r\n    elif i == 5:\r\n        return 2,1\r\n    else: return 2,4\r\ndef end_aligner (i):\r\n    if i == 1:\r\n        return 4,3\r\n    elif i == 2:\r\n        return 5,1\r\n    elif i == 3:\r\n        return 8,8\r\n    elif i == 4:\r\n        return 1,7\r\n    elif i == 5:\r\n        return 3,7\r\n    else: return 7,6\r\ndef maze_chooser (i):\r\n    if i == 1:\r\n        maze = [[2,4,2,1,4,5,2],\r\n                [0,1,2,3,5,3,1],\r\n                [2,0,4,4,1,2,4],\r\n                [2,5,5,3,2,0,1],\r\n                [4,3,3,2,1,0,1]]\r\n        return maze\r\n    elif i == 2:\r\n        maze = [[1,3,2,5,1,4,3],\r\n                [2,1,3,1,3,2,5],\r\n                [3,0,5,0,1,2,2],\r\n                [5,3,2,1,5,0,3],\r\n                [2,4,1,0,0,2,0],\r\n                [4,0,2,1,5,3,4],\r\n                [1,5,1,0,2,4,1]]\r\n        return maze\r\n    elif i == 3:\r\n        maze = [[2,0,2,0,2,0,0,2,2,0],\r\n                [1,2,3,5,2,1,2,5,1,2],\r\n                [2,0,2,2,1,2,1,2,4,2],\r\n                [2,0,1,0,1,1,1,0,0,1],\r\n                [1,1,0,0,5,0,3,2,2,2],\r\n                [2,2,2,2,1,0,1,2,1,0],\r\n                [1,0,2,1,3,1,4,3,0,1],\r\n                [2,0,5,1,5,2,1,2,4,1],\r\n                [1,2,2,2,0,2,0,1,1,0],\r\n                [5,1,2,1,1,1,2,0,1,2]]\r\n        return maze\r\n    elif i == 4:\r\n        maze = [[0, 0, 2, 0, 2, 0, 0, 2, 2, 0],\r\n                [0, 1, 1, 1, 1, 1, 2, 5, 1, 2],\r\n                [0, 0, 1, 2, 1, 2, 1, 2, 4, 2],\r\n                [0, 0, 1, 0, 1, 1, 1, 0, 0, 1],\r\n                [1, 0, 0, 0, 1, 0, 1, 2, 2, 2],\r\n                [2, 0, 2, 2, 1, 0, 1, 2, 1, 0],\r\n                [1, 0, 2, 1, 1, 1, 4, 3, 0, 1],\r\n                [2, 1, 1, 1, 1, 2, 1, 2, 4, 1],\r\n                [1, 2, 2, 2, 0, 2, 0, 1, 1, 0],\r\n                [5, 1, 2, 1, 1, 1, 2, 0, 1, 2]]\r\n        return maze\r\n    elif i == 5:\r\n        maze = [[1, 2, 3, 4, 5, 1, 2, 3, 4, 5],\r\n                [5, 1, 2, 3, 4, 5, 1, 2, 3, 4],\r\n                [4, 5, 1, 2, 3, 4, 5, 1, 2, 3],\r\n                [3, 4, 5, 1, 2, 3, 4, 5, 1, 2],\r\n                [2, 3, 4, 5, 1, 2, 3, 4, 5, 1],\r\n                [1, 2, 3, 4, 5, 1, 2, 3, 4, 5],\r\n                [5, 1, 2, 3, 4, 5, 1, 2, 3, 4],\r\n                [4, 5, 1, 2, 3, 4, 5, 1, 2, 3],\r\n                [3, 4, 5, 1, 2, 3, 4, 5, 1, 2],\r\n                [2, 3, 4, 5, 1, 2, 3, 4, 5, 1]]\r\n        return maze\r\n    else:\r\n        maze = [[1, 1, 1, 0, 1, 1, 1, 1, 1, 1],\r\n                [1, 1, 1, 0, 1, 1, 1, 1, 1, 1],\r\n                [1, 1, 1, 0, 1, 1, 1, 1, 1, 1],\r\n                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\r\n                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]\r\n        return maze\r\n\r\n\r\ndef calculate_path_cost(maze, path):\r\n    if path is None: return \"No solution found\"\r\n    total_cost = 0\r\n    for position in path[1:]:  #Ignore the starting position cost\r\n        x, y = position\r\n        total_cost += maze[x][y]\r\n    return total_cost\r\n\r\ndef calculate_manhattan_distance(star, end):\r\n    return abs(end[0] - star[0]) + abs(end[1] - star[1])\r\n\r\n\r\ndef timeing_different_heuristic_formulas(mazeOption):\r\n    print(f\"Maze: {mazeOption}\")\r\n    maze = maze_chooser(mazeOption)\r\n\r\n    start = start_aligner(mazeOption)\r\n    end = end_aligner(mazeOption)\r\n\r\n    times = []\r\n\r\n    for integer_value in range(4):  # 0 to 3\r\n        start_time = timeit.default_timer()\r\n        astar(maze, start, end, integer_value)  # Call your function here\r\n        elapsed = timeit.default_timer() - start_time\r\n        times.append(elapsed)\r\n        print(\r\n            f\"Execution time for h({integer_value}) (Start: {start}, End: {end}): {elapsed:.10f} seconds\")\r\n\r\n    return times\r\n\r\ndef make_graph():\r\n    heuristic_times = {i: [] for i in range(4)}  # Store times for each heuristic\r\n\r\n    # Run the function for all maps\r\n    for maze_option in range(1, 6):  # Assuming maps are numbered from 1 to 5\r\n        times = timeing_different_heuristic_formulas(maze_option)\r\n        for i, time in enumerate(times):\r\n            heuristic_times[i].append(time)\r\n\r\n    # Calculate average times for each heuristic function\r\n    average_times = [sum(heuristic_times[i]) / len(heuristic_times[i]) for i in range(4)]\r\n\r\n    # Plotting the graph\r\n    plt.bar(range(4), average_times, color=['blue', 'green', 'red', 'orange'])\r\n    plt.xlabel('Heuristic Function')\r\n    plt.ylabel('Average Execution Time (seconds)')\r\n    plt.title('Average Execution Time for Heuristic Functions Across All Maps')\r\n    plt.xticks(range(4), [f'h({i})' for i in range(4)])\r\n    plt.show()\r\n\r\n\r\n\"\"\"\r\n=====================================================================================\r\n===================================== MAIN ==========================================\r\n=====================================================================================\r\n\"\"\"\r\n\r\ndef main():\r\n    #Do not use unless you want to generate graph\r\n    #   Utilities.make_graph()\r\n    \"\"\"\r\n    Code might look weird since it was originally two files with a utility class.\r\n    Had to merge them for this assignment.\r\n    If the original code wants to be seen follow this link:\r\n    https://github.com/WokyDoky/Pathfinding-with-A-Search/blob/addingMoreHeuristicValues/Utilities.py\r\n    \"\"\"\r\n    print(\"Enter 2 values, first value will choose a map, second value will choose a heuristic.\")\r\n    print(\"Values for the map range from 1 - 5 and for the heuristic value from 1 - 4.\")\r\n\r\n    # Read input and split, then cast to integers\r\n    value1, value2 = map(int, input(\"Separate values by a space > \").split())\r\n\r\n    maze_option = value1\r\n    maze = maze_chooser(maze_option)\r\n\r\n    start = start_aligner(maze_option)\r\n    end = end_aligner(maze_option)\r\n\r\n    path = astar(maze, start, end, value2)\r\n\r\n    print_info(start, end, maze, path)\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n\r\n#Code by Nicholas Swift, modified by Jesus Daniel Benavente.
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Example.py b/Example.py
--- a/Example.py	(revision a3b5fa52f9d33fab7bbf69aaf1aa7ce2feefa7f0)
+++ b/Example.py	(date 1727879712328)
@@ -260,6 +260,8 @@
     return abs(end[0] - star[0]) + abs(end[1] - star[1])
 
 
+
+
 def timeing_different_heuristic_formulas(mazeOption):
     print(f"Maze: {mazeOption}")
     maze = maze_chooser(mazeOption)
@@ -299,6 +301,12 @@
     plt.xticks(range(4), [f'h({i})' for i in range(4)])
     plt.show()
 
+"""
+    Code might look weird since it was originally two files with a utility class.
+    Had to merge them for this assignment.
+    If the original code wants to be seen follow this link:
+    https://github.com/WokyDoky/Pathfinding-with-A-Search/blob/addingMoreHeuristicValues/Utilities.py
+"""
 
 """
 =====================================================================================
@@ -309,12 +317,6 @@
 def main():
     #Do not use unless you want to generate graph
     #   Utilities.make_graph()
-    """
-    Code might look weird since it was originally two files with a utility class.
-    Had to merge them for this assignment.
-    If the original code wants to be seen follow this link:
-    https://github.com/WokyDoky/Pathfinding-with-A-Search/blob/addingMoreHeuristicValues/Utilities.py
-    """
     print("Enter 2 values, first value will choose a map, second value will choose a heuristic.")
     print("Values for the map range from 1 - 5 and for the heuristic value from 1 - 4.")
 
@@ -327,7 +329,13 @@
     start = start_aligner(maze_option)
     end = end_aligner(maze_option)
 
+    start_time = timeit.default_timer()
     path = astar(maze, start, end, value2)
+    elapsed = timeit.default_timer() - start_time
+    print(
+        f"Execution time for h({value2}) (Start: {start}, End: {end}): {elapsed:.10f} seconds")
+
+
 
     print_info(start, end, maze, path)
 
